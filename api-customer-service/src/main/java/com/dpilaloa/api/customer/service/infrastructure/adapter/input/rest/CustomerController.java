package com.dpilaloa.api.customer.service.infrastructure.adapter.input.rest;

import com.dpilaloa.api.customer.service.application.ports.input.CreateCustomerUseCase;
import com.dpilaloa.api.customer.service.application.ports.input.DeleteCustomerUseCase;
import com.dpilaloa.api.customer.service.application.ports.input.GetCustomerUseCase;
import com.dpilaloa.api.customer.service.application.ports.input.UpdateCustomerUseCase;
import com.dpilaloa.api.customer.service.domain.model.Customer;
import com.dpilaloa.api.customer.service.infrastructure.adapter.input.rest.mapper.CustomerRestMapper;
import com.dpilaloa.api.customer.service.infrastructure.input.adapter.rest.customer.service.api.CustomersApi;
import com.dpilaloa.api.customer.service.infrastructure.input.adapter.rest.customer.service.models.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

import java.net.URI;
import java.util.UUID;

/**
 * Customer REST Controller - Infrastructure Layer (Primary Adapter)
 * <p>
 * Implements the CustomersApi interface generated by OpenAPI.
 * Handles HTTP requests and delegates to application use cases.
 * <p>
 * HEXAGONAL ARCHITECTURE:
 * This is a PRIMARY ADAPTER that implements REST endpoints.
 * It depends on INPUT PORTS (use case interfaces) from the application layer.
 * <p>
 * SOLID PRINCIPLES APPLIED:
 * - Dependency Inversion Principle (DIP): Depends on use case interfaces, not implementations
 * - Single Responsibility Principle (SRP): Only handles HTTP request/response conversion
 * - Interface Segregation Principle (ISP): Implements CustomersApi from OpenAPI contract
 * <p>
 * DESIGN PATTERNS APPLIED:
 * - Adapter Pattern: Adapts HTTP requests to application use cases
 * - Facade Pattern: Provides unified interface to multiple use cases
 * - Controller Pattern: Handles web requests and responses
 */
@Slf4j
@RestController
@RequestMapping("/api/v1")
@RequiredArgsConstructor
public class CustomerController implements CustomersApi {

    // Input Ports (Use Cases) - injected via constructor
    private final CreateCustomerUseCase createCustomerUseCase;
    private final GetCustomerUseCase getCustomerUseCase;
    private final UpdateCustomerUseCase updateCustomerUseCase;
    private final DeleteCustomerUseCase deleteCustomerUseCase;

    // Mapper for DTO â†” Domain conversion
    private final CustomerRestMapper mapper;

    /**
     * GET /customers
     * Get paginated list of customers with optional filters.
     */
    @Override
    public Mono<ResponseEntity<CustomerPageResponse>> getCustomers(
            UUID xRequestId,
            Integer page,
            Integer size,
            String sort,
            String name,
            String identification,
            Boolean state,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("GET /customers - page: {}, size: {}, requestId: {}", page, size, xRequestId);

        // Get customers from use case
        return getCustomerUseCase.getAllCustomers(page, size)
                .map(mapper::customerToResponse)
                .collectList()
                .zipWith(getCustomerUseCase.count())
                .map(tuple -> {
                    // Build page metadata
                    PageMetadata pageMetadata = new PageMetadata();
                    pageMetadata.setSize(size);
                    pageMetadata.setNumber(page);
                    pageMetadata.setTotalElements(tuple.getT2().intValue());
                    pageMetadata.setTotalPages((int) Math.ceil((double) tuple.getT2() / size));

                    // Build response
                    CustomerPageResponse response = new CustomerPageResponse();
                    response.setContent(tuple.getT1());
                    response.setPage(pageMetadata);

                    return ResponseEntity.ok(response);
                });
    }

    /**
     * POST /customers
     * Create a new customer.
     */
    @Override
    public Mono<ResponseEntity<CustomerResponse>> createCustomer(
            UUID xRequestId,
            CustomerCreateRequest customerCreateRequest,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("POST /customers - requestId: {}, correlationId: {}", xRequestId, xCorrelationId);

        // Convert DTO to domain model (Customer extends Person, so all fields are mapped directly)
        Customer customer = mapper.requestToCustomer(customerCreateRequest);

        // Extract raw password from request
        String rawPassword = customerCreateRequest.getPassword();

        // Execute use case with correlation-id for distributed tracing
        String correlationId = getCorrelationId(xCorrelationId);

        return createCustomerUseCase.createCustomer(customer, rawPassword, correlationId)
                .map(result -> {
                    // Convert domain model to DTO with JWT token
                    CustomerResponse response = mapper.customerToResponseWithToken(
                            result.customer(),
                            result.jwtToken()
                    );

                    // Build Location header
                    URI location = URI.create("/api/v1/customers/" + result.customer().getCustomerId());

                    log.info("Customer created successfully: {} with correlation-id: {}",
                            result.customer().getCustomerId(), correlationId);

                    return ResponseEntity
                            .created(location)
                            .body(response);
                });
    }

    /**
     * GET /customers/{customerId}
     * Get customer by ID.
     */
    @Override
    public Mono<ResponseEntity<CustomerResponse>> getCustomerById(
            UUID customerId,
            UUID xRequestId,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("GET /customers by ID/{} - requestId: {}", customerId, xRequestId);

        return getCustomerUseCase.getCustomerById(customerId)
                .map(mapper::customerToResponse)
                .map(ResponseEntity::ok);
    }

    /**
     * PUT /customers/{customerId}
     * Update customer completely.
     */
    @Override
    public Mono<ResponseEntity<CustomerResponse>> updateCustomer(
            UUID customerId,
            UUID xRequestId,
            CustomerUpdateRequest customerUpdateRequest,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("PUT /customers/{} - requestId: {}, correlationId: {}", customerId, xRequestId, xCorrelationId);

        // Extract correlation-id for distributed tracing
        String correlationId = getCorrelationId(xCorrelationId);

        // Get existing customer to obtain current version
        return getCustomerUseCase.getCustomerById(customerId)
                .flatMap(existingCustomer -> {
                    // Convert DTO to domain model (Customer extends Person, so map to Customer directly)
                    Customer updatedCustomer = mapper.updateRequestToCustomer(customerUpdateRequest);

                    // Build Person object with updated data (preserving personId and identification)
                    updatedCustomer.toBuilder()
                            .personId(existingCustomer.getPersonId())
                            .name(updatedCustomer.getName())
                            .gender(updatedCustomer.getGender())
                            .age(updatedCustomer.getAge())
                            .identification(existingCustomer.getIdentification()) // Cannot be updated
                            .address(updatedCustomer.getAddress())
                            .phone(updatedCustomer.getPhone())
                            .build();

                    // If password is provided, update it
                    if (customerUpdateRequest.getPassword() != null && !customerUpdateRequest.getPassword().isEmpty()) {
                        return updateCustomerUseCase.updatePassword(
                                customerId,
                                existingCustomer.getPassword(), // This is a simplification
                                customerUpdateRequest.getPassword(),
                                existingCustomer.getVersion(),
                                correlationId
                        ).flatMap(customer ->
                                updateCustomerUseCase.updateCustomer(
                                        customerId,
                                        updatedCustomer,
                                        customer.getVersion(),
                                        correlationId
                                )
                        );
                    } else {
                        return updateCustomerUseCase.updateCustomer(
                                customerId,
                                updatedCustomer,
                                existingCustomer.getVersion(),
                                correlationId
                        );
                    }
                })
                .map(mapper::customerToResponse)
                .map(ResponseEntity::ok);
    }

    /**
     * PATCH /customers/{customerId}
     * Partially update customer.
     */
    @Override
    public Mono<ResponseEntity<CustomerResponse>> patchCustomer(
            UUID customerId,
            UUID xRequestId,
            CustomerPatchRequest customerPatchRequest,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("PATCH /customers/{} - requestId: {}, correlationId: {}", customerId, xRequestId, xCorrelationId);

        // Extract correlation-id for distributed tracing
        String correlationId = getCorrelationId(xCorrelationId);

        // Get existing customer
        return getCustomerUseCase.getCustomerById(customerId)
                .flatMap(existingCustomer -> {
                    // Handle state change
                    if (customerPatchRequest.getState() != null) {
                        if (customerPatchRequest.getState()) {
                            return updateCustomerUseCase.activateCustomer(
                                    customerId,
                                    existingCustomer.getVersion(),
                                    correlationId
                            );
                        } else {
                            return updateCustomerUseCase.deactivateCustomer(
                                    customerId,
                                    existingCustomer.getVersion(),
                                    correlationId
                            );
                        }
                    }

                    // Handle password change
                    if (customerPatchRequest.getPassword() != null && !customerPatchRequest.getPassword().isEmpty()) {
                        return updateCustomerUseCase.updatePassword(
                                customerId,
                                existingCustomer.getPassword(), // Simplification
                                customerPatchRequest.getPassword(),
                                existingCustomer.getVersion(),
                                correlationId
                        );
                    }

                    // Return existing customer if no changes
                    return Mono.just(existingCustomer);
                })
                .map(mapper::customerToResponse)
                .map(ResponseEntity::ok);
    }

    /**
     * DELETE /customers/{customerId}
     * Hard delete customer.
     */
    @Override
    public Mono<ResponseEntity<Void>> deleteCustomer(
            UUID customerId,
            UUID xRequestId,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("DELETE /customers/{} - requestId: {}, correlationId: {}", customerId, xRequestId, xCorrelationId);

        return deleteCustomerUseCase.deleteCustomer(customerId, getCorrelationId(xCorrelationId))
                .then(Mono.just(ResponseEntity.noContent().build()));
    }

    /**
     * GET /customers/{customerId}/validate.
     * Validate if customer exists and is active.
     */
    @Override
    public Mono<ResponseEntity<CustomerValidationResponse>> validateCustomer(
            UUID customerId,
            UUID xRequestId,
            UUID xCorrelationId,
            ServerWebExchange exchange
    ) {
        log.info("GET /customers/{}/validate - requestId: {}", customerId, xRequestId);

        return getCustomerUseCase.getCustomerById(customerId)
                .map(customer -> {
                    CustomerValidationResponse response = mapper.customerToValidationResponse(customer);

                    // Return 422 if customer is inactive
                    if (!customer.isActive()) {
                        return ResponseEntity
                                .status(HttpStatus.UNPROCESSABLE_ENTITY)
                                .body(response);
                    }

                    return ResponseEntity.ok(response);
                });
    }

    /**
     * GET xCorrelationId
     * Validate header xCorrelationId.
     */
    private String getCorrelationId(UUID xCorrelationId){
        // Extract correlation-id for distributed tracing
        return xCorrelationId != null ? xCorrelationId.toString() : UUID.randomUUID().toString();
    }

}
